
# Cache

### 캐시 기본 동작
캐시가 없을 때
1) 클라이언트가 특정 이미지를 서버에 요청함
2) 서버는 그 이미지의 헤더(0.1M)와 바디(1.1M)를 포함한 200OK 응답 메세지를 내려줌 (총1.1M가 내려짐)
3) 캐시가 없으므로 같은 이미지를 다시 요청하면 똑같은 내용을 또 내려줌

즉 캐시가 없으면
1) 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 한다.
2) 매번 다운로드를 받아야 하므로 사용자는 로딩 속도가 매우 느리다.

캐시 적용
1) 클라이언트가 특정 이미지를 서버에 요청함
2) 서버는 헤더에 cache-control을 넣어 캐시가 유요한 시간을 명시 후 응답 메세지를 보냄
3) 브라우저는 헤더에 cache-contol이 있으면 응답 결과를 캐시에 저장한다.
4) 두 번째 같은 이미지를 요청하기 전 캐시를 먼저 확인하고 유효한 시간이라면 캐시에서 바로 가져온다.

캐시를 적용하면
1) 한번 저장하면 유효기간 동안 네트워크를 사용하지 않아도 됨
2) 브라우저 로딩 속도가 빠름

만약 캐시 시간이 초과되면?
1) 다시 요청하고 서버는 똑같은 메세지를 내려줌
2) 브라우저는 기존의 캐시를 지우고 갱신한다.


### 검증 헤더와 조건부 요청
캐시 기간이 만료된 후에 용량이 큰 데이터를 다시 요청할 때 <br/>
    -> 서버가 데이터를 변경했다면 당연히 새로 내려야겠지만, 변경하지 않았다면 비효율적인 작업<br/>
**로컬 캐시와 서버의 데이터가 안 바꼈다는 작업이 필요 ->검증 헤더 사용**

검증 헤더 추가 (Last-Modified)
1) 브라우저가 특정 이미 서버에 요청
2) 헤더에 Last-Modified(마지막에 수정된 시간)를 추가하여 200응답을 보냄 -> 이 데이터가 마지막에 수정된 시간을 의미
3) 브라우저는 응답 결과를 캐시에 저장
4) 60초 경과 후 if-modified-since를 통해 해당 데이터가 언제 마지막으로 수정됐는지 서버에 알려줌
5) 서버에서 해당 데이터의 수정 날짜가 같다면 수정이 필요 없으므로 304 Not Modified 응답을 보냄
> Cache-Contol, Cache-Modified도 다시 보냄 + Http Body가 없음(데이터 수정이 없으므로)
6) 브라우저는 다시 데이터를 캐시에 세팅 후 사용

만약 데이터가 변경되었다가 다시 기존의 데이터로 변경된다면 ?<br/>
-> Last-Modified가 수정되었으므로 다시 내려받아야 함

이 문제를 해결하기 위해 Etag 사용
- Etag : 캐시용 데이터에 임의의 고유한 이름을 달아둠<br/>
클라이언트 입장에서 Etag도 같이 보내서 같으면 유지, 다르면 다시 받음
